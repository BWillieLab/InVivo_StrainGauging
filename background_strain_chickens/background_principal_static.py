# -*- coding: utf-8 -*-
"""
Created on Mon Oct 18 10:10:48 2021

@author: IVitienes
"""
import numpy as np
import os, tkinter.filedialog
import tkinter as tk
from scipy import signal
import pandas as pd
import math


# Written by Isabela Vitienes 2021

####################################################################################################################################
# This code automatically analyzes segments of strain during static activities (e.g. perching) to obtain peak principal strains.   #
# Code takes as input strain segments AND ginputs generated by analyzing axial strain, along with swing values for each chicken.   #                                        
# Areas of the code that should be tailored to each use are indicated by *                                                         #
# The code is designed for data from a rosette strain gauge.                                                                       #
# Outputs are saved in the same location as the input file.                                                                        #
####################################################################################################################################

# Input data formatting:
# You should have a list containing the segment files and the ginput files for each segment file.
# There must be a 1:1 correspondence with segments and ginputs. When selecting the files make sure list is ordered alphabetically.
# As input to this code, you should therefore select a list of files, where there is a segment followed by its ginput file. 
# Outputs saved in same location as inputs.


# LICENSE
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 2 of the License, or (at your option) any later version.
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
# For more details: https://www.gnu.org/licenses/gpl-3.0.html.




# Get segments
# Selection should be ordered by name, such that in the resulting list of file names, each segment is followed by its ginput file. 
Initialdir = "S:\Projects_Isabela\Current_projects\Chickens\MyStudy\Data\Flock_three\strain_gauging\exported\background"
Title = "Order by name and select all segments"
root = tk.Tk()
root.focus_force()
ftypes=[("excel", "*.xlsx")]
segment_paths = tk.filedialog.askopenfilenames(initialdir=Initialdir, parent=root,title=Title,filetypes=ftypes)
segment_names = [os.path.splitext(os.path.basename(file))[0] for file in segment_paths]
files = [segment_paths,segment_names]
root.withdraw()


# Input file with swing values per chicken
Initialdir = "S:\Projects_Isabela\Current_projects\Chickens\MyStudy\Data\Flock_three\strain_gauging\exported\background"
Title = "Perching swing values"
root = tk.Tk()
root.focus_force()
ftypes=[("excel", "*.xlsx")]
swing_path = tk.filedialog.askopenfilenames(initialdir=Initialdir, parent=root,title=Title,filetypes=ftypes)
swing_name = [os.path.splitext(os.path.basename(file))[0] for file in swing_path]
root.withdraw()


# Get swing strain for data
df2 = pd.read_excel(swing_path[0])
swings = df2.to_numpy()


# Now, work with each segment
results_compiled = [0,0,0,0,0,0,0]
# Ls = len(ginput_names) 
Ls = len(segment_names)
for k in range(Ls):
    
    # Extract raw data
    df1 = pd.read_excel(segment_paths[k])
    dfs = df1.to_numpy()

    strain_index = dfs[:,0]
    strain_time = dfs[:,1]
    # *** Only need rosette strain data for principal strains, adjust channels depending on your data 
    strain1 = dfs[:,4]
    strain2 = dfs[:,6]
    strain3 = dfs[:,8]
    
    # Filter strains
    # *** Cutoff frequency selected to ensure that it is above the Nyquist frequency for the activities you have sampled. 
    fs = 1000  # Sampling frequency
    fc = 40  # Cut-off frequency of the filter
    w = fc / (fs / 2) # Normalize the frequency
    b, a = signal.butter(4, w, 'low')
    strain1_filt = signal.filtfilt(b, a, strain1)
    b, a = signal.butter(4, w, 'low')
    strain2_filt = signal.filtfilt(b, a, strain2)
    b, a = signal.butter(4, w, 'low')
    strain3_filt = signal.filtfilt(b, a, strain3)
    
    strains_filt = np.vstack([strain1_filt, strain2_filt, strain3_filt])
    strains_filt = np.matrix.transpose(strains_filt)
    
    
    FOI = segment_names[k]
    if FOI[3] == '_':
        ID = FOI[:3]
    else:
        ID = FOI[:4]
    seg = FOI[-2:] 
    if seg[0] == '_':
        seg = seg[1:] 
    
    R = len(swings)
    sR1 = float("nan")
    sR2 = float("nan")
    sR3 = float("nan")
    
    for r in range(R):
        if swings[r,0] == int(ID):
            sR1 = swings[r,1]
            sR2 = swings[r,2]
            sR3 = swings[r,3]
            break
    
    # Zero the raw strains
    strain1_zeroed = strain1_filt - sR1
    strain2_zeroed = strain2_filt - sR2
    strain3_zeroed = strain3_filt - sR3
    
    # Save zeroed data
    zeroed = np.vstack([strain1_zeroed, strain2_zeroed, strain3_zeroed])
    zeroed = np.matrix.transpose(zeroed)
    name = segment_names[k]
    POI = segment_paths[k]
    filepath = POI[:-5] + "_zeroed.xlsx"
    dfresults = pd.DataFrame(zeroed)
    dfresults.to_excel(filepath)          
    
  
    # Convert to principal strain
    # Equations from Biewener 1992, chapter 6.
    strain_pr_max = ((strain1_zeroed + strain3_zeroed) / 2) + (1/2) * np.sqrt((strain1_zeroed - strain2_zeroed)**2 + (strain2_zeroed - strain3_zeroed)**2)))
    strain_pr_min = ((strain1_zeroed + strain3_zeroed) / 2) - (1/2) * np.sqrt((strain1_zeroed - strain2_zeroed)**2 + (strain2_zeroed - strain3_zeroed)**2)))
    
    # 'theta' is angle from principal axis to axis of gauge 1 (strain1)
    # Positive angle is CCW, negative is CW
    strain_pr_theta_radians = (1 / 2) * np.arctan(((-1)*strain1_zeroed + 2 * strain2_zeroed - strain3_zeroed) / (strain1_zeroed - strain3_zeroed))
    
    # Convert to degrees
    strain_pr_theta = strain_pr_theta_radians * 180 / math.pi #in degrees
    
    # Compute shear strain
    shear = 2 * np.sin(strain_pr_theta_radians) * np.cos(strain_pr_theta_radians) * (strain_pr_max - strain_pr_min)
            
    # Compile
    strain_pr = np.vstack([strain_index, strain_time, strain1_filt, strain2_filt, strain3_filt, strain_pr_max, strain_pr_min, strain_pr_theta, shear])
    strain_pr = np.matrix.transpose(strain_pr)
    
    # Save principal strain data
    pr_path = POI[:-5] + "_principal_strain.xlsx"
    dfresultspr = pd.DataFrame(strain_pr)
    dfresultspr.to_excel(pr_path)
    
    
    
    #############################################################
    ### Compute derived parameters in principal strain domain ###
    #############################################################
    
    # Method is the same as that used for axial data.

    
    mean_pr_max = np.mean(strain_pr_max)
    mean_pr_min = np.mean(strain_pr_min)
    mean_pr_theta = np.mean(strain_pr_theta)
    sd_pr_max = np.std(strain_pr_max)
    sd_pr_min = np.std(strain_pr_min)
    sd_pr_theta = np.std(strain_pr_theta)
    mean_shear = np.mean(shear)
    sd_shear = np.std(shear)
    
    
    results2 = np.vstack([ID, mean_pr_max, mean_pr_min, mean_pr_theta, sd_pr_max, sd_pr_min, sd_pr_theta, mean_shear, sd_shear])
    results2 = np.matrix.transpose(results2)
    results_compiled = np.vstack([results_compiled, results2])
        
    savepath = POI[:-5] + "_principal_strain_results.xlsx"
        
    dfresults = pd.DataFrame(results2)
    dfresults.to_excel(savepath)
    
    
# Compile and save file
compiled = results_compiled[1:,:]
N = len(segment_names[0])
path = segment_paths[0]
NN = N + 5
savepath = path[:-NN] + "_principal_static_compiled_results.xlsx"
dfresults4 = pd.DataFrame(compiled)
dfresults4.to_excel(savepath) 
    
    
    
    
    

